!!!grep - g/re/p > re 부분의 정규표현식 퍄턴과 일치하는 모든 행 출력 

grep [option] pattern [file]

option
-v --invert-match 일치하지 않는 대상을 찾는다 
-n --line-number  검색 결과에 파일의 라인 넘버를 보여준다 
-c --count        검색 결과의 숫자를 센다 
-e foo -e bar     # or 검색 
-H                파일 이름 표시 
-F "[0-9]"        0-9사이 말고 [0-9]그대로 인식 


#meta character 설명 (pattern) 
. 1개의 문자 매치 
* 앞문자가 0회이상 매치
{n} 앞문자가 정확히 n회 매치 
{n,m} 앞문자가 n화 이상 m 회이하 매치 
[] 대괄호에 포함된문자중 한개와 매치 
[^ ] 대괄호 안에 ^뒤에 있는 문자들을 제외 
[ - ] 대괄호안 문자 범위에 있는  문자들 매치 
() 표현식 그룹화 
^ 문자열 라인의 처음 
$ 문자열 라인의 마지막 
? 앞 문자가 0 또는 1회 매치 
+ 앞문자가 1회 이상 매치 
| 표현식 논리 OR 

ex) grep "\*" FILE.txt    파일에서 문자 * 검색 (\로 뒤에 문자를 일반문자로 인식) 
    grep "\." FILE.txt 
    grep -v "\.$" FILE.txt   .으로 끝나지 않는 라인 찾기 
    
grep -v "\#" star-fusion.fusion_predictions.tsv | awk '{printf ("%s\n",$1)}' > 57257-NL.txt
grep -v "\#" star-fusion.fusion_predictions.tsv | awk '{printf ("%s\n",$1)}' | sort -u > 75859-RMLS.txt

----------------------------------------------------------------------------------------------------

!!! sort 명령어 

-r reverse 내용을 역순으로 정렬
-n numeric 숫자 옵션으로 정렬
-u unique 
-R random 하게 섞음 
-c check 
-k 기준필드 
-t field separator 

ex) sort -c -n sort.txt 
    sort test -k1
    grep -c test * | sort -t: -k2 -n -r   #grep 으로 파일별로 test가 몇번 나타나는지 체크한 후 , sort 로 빈도수 기준 정렬  
  > tags:902
    pacakes.json:1
    generate.js:1
    test.md:0

-----------------------------------------------------------------------------------------------------------

!!!perl 

perl -i -aF -n(p)le '~~~~~~~'  or  perl -i -F -an(p)le '~~~~~~~'

option 
-i 현재 수정중인 파일을 표준출력으로 덮어쓰라는 뜻 (-i.old 이런식으로 백업하는것이 좋음) 
-a 공백을 기중으로 자동으로 열을 나누는 옵션 
-F -a와 같이 써서 구분자를 지정(,;등등) 
-n 입력을 한줄씩 읽어서 처리 
-p 
ls | perl -ne 'print'



-----------------------------------------------------------------------------------------------------------
!! cut [option] [file] 

-c 잘라낼 곳의 위치 
-f field 
-d 필드를 구분하는 문자 , 디폴트는 탭 
-s 필드 구분자를 포함할 수 없다면 그 행은 하지 않는다.

    
